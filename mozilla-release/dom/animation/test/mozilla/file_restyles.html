<!doctype html>
<head>
<meta charset=utf-8>
<title>Tests restyles caused by animations</title>
<script>
var ok = opener.ok.bind(opener);
var is = opener.is.bind(opener);
var todo = opener.todo.bind(opener);
var todo_is = opener.todo_is.bind(opener);
var info = opener.info.bind(opener);
var original_finish = opener.SimpleTest.finish;
var SimpleTest = opener.SimpleTest;
SimpleTest.finish = function finish() {
  self.close();
  original_finish();
}
</script>
<script src="/tests/SimpleTest/EventUtils.js"></script>
<script src="/tests/SimpleTest/SpawnTask.js"></script>
<script src="/tests/SimpleTest/paint_listener.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css">
<style>
@keyframes opacity {
  from { opacity: 1; }
  to { opacity: 0; }
}
@keyframes opacity-without-end-value {
  from { opacity: 0; }
}
@keyframes background-color {
  from { background-color: red; }
  to { background-color: blue; }
}
@keyframes rotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
@keyframes move-in {
  from { transform: translate(120%, 120%); }
  to { transform: translate(0%, 0%); }
}
div {
  /* Element needs geometry to be eligible for layerization */
  width: 100px;
  height: 100px;
  background-color: white;
}
</style>
</head>
<body>
<script>
'use strict';

function observeStyling(frameCount, onFrame) {
  var docShell =
    SpecialPowers.wrap(window)
                 .QueryInterface(SpecialPowers.Ci.nsIInterfaceRequestor)
                 .getInterface(SpecialPowers.Ci.nsIWebNavigation)
                 .QueryInterface(SpecialPowers.Ci.nsIDocShell);

  docShell.recordProfileTimelineMarkers = true;
  docShell.popProfileTimelineMarkers();

  return new Promise(resolve => {
    return waitForAnimationFrames(frameCount, onFrame).then(() => {
      var markers = docShell.popProfileTimelineMarkers();
      docShell.recordProfileTimelineMarkers = false;
      var stylingMarkers = markers.filter((marker, index) => {
        return marker.name == 'Styles' && marker.isAnimationOnly;
      });
      resolve(stylingMarkers);
    });
  });
}

function ensureElementRemoval(aElement) {
  return new Promise(resolve => {
    aElement.remove();
    waitForAllPaintsFlushed(resolve);
  });
}

function waitForWheelEvent(aTarget) {
  return new Promise(resolve => {
    // Get the scrollable target element position in this window coordinate
    // system to send a wheel event to the element.
    var targetRect = aTarget.getBoundingClientRect();
    var centerX = targetRect.left + targetRect.width / 2;
    var centerY = targetRect.top + targetRect.height / 2;

    sendWheelAndPaintNoFlush(aTarget, centerX, centerY,
                             { deltaMode: WheelEvent.DOM_DELTA_PIXEL,
                               deltaY: targetRect.height },
                             resolve);
  });
}

// Returns true if |aAnimation| begins at the current timeline time.  We
// sometimes need to detect this case because if we started an animation
// asynchronously (e.g. using play()) and then ended up running the next frame
// at precisely the time the animation started (due to aligning with vsync
// refresh rate) then we won't end up restyling in that frame.
function startsRightNow(aAnimation) {
  return aAnimation.startTime === aAnimation.timeline.currentTime &&
         aAnimation.currentTime === 0;
}

function tweakExpectedRestyleCount(aAnimation, aExpectedRestyleCount) {
  // Normally we expect one restyling for each requestAnimationFrame (as
  // called by observeRestyling) PLUS one for the last frame because of bug
  // 1193394.  However, we won't observe that initial restyling unless BOTH of
  // the following two conditions hold:
  //
  // 1. We are running *before* restyling happens.
  // 2. The animation actually needs a restyle because it started prior to
  //    this frame.  Even if (1) is true, in some cases due to aligning with
  //    the refresh driver, the animation fame in which the ready promise is
  //    resolved happens to coincide perfectly with the start time of the
  //    animation.  In this case no restyling is needed so we won't observe
  //    an additional restyle.
  if (hasConformantPromiseHandling) {
    // If we have the conformant Promise handling and |aAnimation| begins at
    // the current timeline time, we will not process restyling in the initial
    // frame.
    if (startsRightNow(aAnimation)) {
      return aExpectedRestyleCount - 1;
    }
  } else if (!startsRightNow(aAnimation)) {
    // If we don't have the conformant Promise handling and |aAnimation|
    // doesn't begin at the current timeline time, we will see an additional
    // restyling in the last frame.
    return aExpectedRestyleCount + 1;
  }
  return aExpectedRestyleCount;
}

var omtaEnabled = isOMTAEnabled();

var isAndroid = !!navigator.userAgent.includes("Android");
var isServo = isStyledByServo();
var hasConformantPromiseHandling;

function add_task_if_omta_enabled(test) {
  if (!omtaEnabled) {
    info(test.name + " is skipped because OMTA is disabled");
    return;
  }
  add_task(test);
}

function isConformant() {
  return new Promise(resolve => {
    let resolvedPromise = false;
    requestAnimationFrame(() => {
      Promise.resolve().then(() => {
        resolvedPromise = true;
      });
    });

    requestAnimationFrame(() => {
      resolve(resolvedPromise);
    });
  });
}

// We need to wait for all paints before running tests to avoid contaminations
// from styling of this document itself.
waitForAllPaints(() => {
  // Drop this once we have the conformant Promise handling(bug 1193394).
  add_task(async function check_conformant_promise_handling() {
    hasConformantPromiseHandling = await isConformant();
  });

  add_task(async function restyling_for_main_thread_animations() {
    var div = addDiv(null, { style: 'animation: background-color 100s' });
    var animation = div.getAnimations()[0];

    await animation.ready;
    ok(!SpecialPowers.wrap(animation).isRunningOnCompositor);

    // We need to tweak expected restyle count depending on animation state and
    // micro task handling.
    const expectedRestyleCount = tweakExpectedRestyleCount(animation, 5);
    var markers = await observeStyling(5);
    is(markers.length, expectedRestyleCount,
       'CSS animations running on the main-thread should update style ' +
       'on the main thread');
    await ensureElementRemoval(div);
  });

  add_task_if_omta_enabled(async function no_restyling_for_compositor_animations() {
    var div = addDiv(null, { style: 'animation: opacity 100s' });
    var animation = div.getAnimations()[0];

    await animation.ready;
    ok(SpecialPowers.wrap(animation).isRunningOnCompositor);

    var markers = await observeStyling(5);
    is(markers.length, 0,
       'CSS animations running on the compositor should not update style ' +
       'on the main thread');
    await ensureElementRemoval(div);
  });

  add_task_if_omta_enabled(async function no_restyling_for_compositor_transitions() {
    var div = addDiv(null, { style: 'transition: opacity 100s; opacity: 0' });
    getComputedStyle(div).opacity;
    div.style.opacity = 1;

    var animation = div.getAnimations()[0];

    await animation.ready;
    ok(SpecialPowers.wrap(animation).isRunningOnCompositor);

    var markers = await observeStyling(5);
    is(markers.length, 0,
       'CSS transitions running on the compositor should not update style ' +
       'on the main thread');
    await ensureElementRemoval(div);
  });

  add_task_if_omta_enabled(async function no_restyling_when_animation_duration_is_changed() {
    var div = addDiv(null, { style: 'animation: opacity 100s' });
    var animation = div.getAnimations()[0];

    await animation.ready;
    ok(SpecialPowers.wrap(animation).isRunningOnCompositor);

    div.animationDuration = '200s';

    var markers = await observeStyling(5);
    is(markers.length, 0,
       'Animations running on the compositor should not update style ' +
       'on the main thread');
    await ensureElementRemoval(div);
  });

  add_task_if_omta_enabled(async function only_one_restyling_after_finish_is_called() {
    var div = addDiv(null, { style: 'animation: opacity 100s' });
    var animation = div.getAnimations()[0];

    await animation.ready;
    ok(SpecialPowers.wrap(animation).isRunningOnCompositor);

    animation.finish();

    var markers = await observeStyling(1);
    if (!hasConformantPromiseHandling) {
      todo_is(markers.length, 1,
              'Bug 1415457: Animations running on the compositor should only ' +
              'update style once after finish() is called');
    } else {
      is(markers.length, 1,
         'Animations running on the compositor should only update style once ' +
         'after finish() is called');

      markers = await observeStyling(1);
      todo_is(markers.length, 0,
              'Bug 1415457: Animations running on the compositor should only ' +
              'update style once after finish() is called');
    }

    markers = await observeStyling(5);
    is(markers.length, 0,
       'Finished animations should never update style after one ' +
       'restyle happened for finish()');

    await ensureElementRemoval(div);
  });

  add_task(async function no_restyling_mouse_movement_on_finished_transition() {
    var div = addDiv(null, { style: 'transition: opacity 1ms; opacity: 0' });
    getComputedStyle(div).opacity;
    div.style.opacity = 1;

    var animation = div.getAnimations()[0];
    var initialRect = div.getBoundingClientRect();

    await animation.finished;
    var markers = await observeStyling(1);
    is(markers.length, 1,
       'Finished transitions should restyle once after Animation.finished ' +
       'was fulfilled');

    var mouseX = initialRect.left + initialRect.width / 2;
    var mouseY = initialRect.top + initialRect.height / 2;
    markers = await observeStyling(5, () => {
      // We can't use synthesizeMouse here since synthesizeMouse causes
      // layout flush.
      synthesizeMouseAtPoint(mouseX++, mouseY++,
                             { type: 'mousemove' }, window);
    });

    is(markers.length, 0,
       'Finished transitions should never cause restyles when mouse is moved ' +
       'on the transitions');
    await ensureElementRemoval(div);
  });

  add_task(async function no_restyling_mouse_movement_on_finished_animation() {
    var div = addDiv(null, { style: 'animation: opacity 1ms' });
    var animation = div.getAnimations()[0];

    var initialRect = div.getBoundingClientRect();

    await animation.finished;
    var markers = await observeStyling(1);
    is(markers.length, 1,
       'Finished animations should restyle once after Animation.finished ' +
       'was fulfilled');

    var mouseX = initialRect.left + initialRect.width / 2;
    var mouseY = initialRect.top + initialRect.height / 2;
    markers = await observeStyling(5, () => {
      // We can't use synthesizeMouse here since synthesizeMouse causes
      // layout flush.
      synthesizeMouseAtPoint(mouseX++, mouseY++,
                             { type: 'mousemove' }, window);
    });

    is(markers.length, 0,
       'Finished animations should never cause restyles when mouse is moved ' +
       'on the animations');
    await ensureElementRemoval(div);
  });

  add_task_if_omta_enabled(async function no_restyling_compositor_animations_out_of_view_element() {
    var div = addDiv(null,
      { style: 'animation: opacity 100s; transform: translateY(-400px);' });
    var animation = div.getAnimations()[0];

    await animation.ready;
    ok(!SpecialPowers.wrap(animation).isRunningOnCompositor);

    var markers = await observeStyling(5);

    is(markers.length, 0,
       'Animations running on the compositor in an out-of-view element ' +
       'should never cause restyles');
    await ensureElementRemoval(div);
  });

  add_task(async function no_restyling_main_thread_animations_out_of_view_element() {
    var div = addDiv(null,
      { style: 'animation: background-color 100s; transform: translateY(-400px);' });
    var animation = div.getAnimations()[0];

    await animation.ready;
    var markers = await observeStyling(5);

    is(markers.length, 0,
       'Animations running on the main-thread in an out-of-view element ' +
       'should never cause restyles');
    await ensureElementRemoval(div);
  });

  add_task_if_omta_enabled(async function no_restyling_compositor_animations_in_scrolled_out_element() {
    var parentElement = addDiv(null,
      { style: 'overflow-y: scroll; height: 20px;' });
    var div = addDiv(null,
      { style: 'animation: opacity 100s; position: relative; top: 100px;' });
    parentElement.appendChild(div);
    var animation = div.getAnimations()[0];

    await animation.ready;

    var markers = await observeStyling(5);

    is(markers.length, 0,
       'Animations running on the compositor for elements ' +
       'which are scrolled out should never cause restyles');

    await ensureElementRemoval(parentElement);
  });

  add_task(
    async function no_restyling_missing_keyframe_opacity_animations_on_scrolled_out_element() {
      var parentElement = addDiv(null,
        { style: 'overflow-y: scroll; height: 20px;' });
      var div = addDiv(null,
        { style: 'animation: opacity-without-end-value 100s; ' +
                 'position: relative; top: 100px;' });
      parentElement.appendChild(div);
      var animation = div.getAnimations()[0];
      await animation.ready;

      var markers = await observeStyling(5);

      is(markers.length, 0,
         'Opacity animations on scrolled out elements should never cause ' +
         'restyles even if the animation has missing keyframes');

      await ensureElementRemoval(parentElement);
    }
  );

  add_task(
    async function restyling_transform_animations_in_scrolled_out_element() {
      if (hasConformantPromiseHandling) {
        return;
      }

      // Skip this test on Android since this test have been failing
      // intermittently.
      // Bug 1413817: We should audit this test still fails once we have the
      // conformant Promise micro task.
      if (isAndroid) {
        return;
      }

      await SpecialPowers.pushPrefEnv({ set: [["ui.showHideScrollbars", 1]] });

      var parentElement = addDiv(null,
        { style: 'overflow-y: scroll; height: 20px;' });
      var div = addDiv(null,
        { style: 'animation: rotate 100s; position: relative; top: 100px;' });
      parentElement.appendChild(div);
      var animation = div.getAnimations()[0];
      var timeAtStart = document.timeline.currentTime;

      ok(!animation.isRunningOnCompositor,
         'The transform animation is not running on the compositor');

      var markers;
      var now;
      while (true) {
        markers = await observeStyling(1);
        // Check restyle markers until 200ms is elapsed.
        now = document.timeline.currentTime;
        if ((now - timeAtStart) >= 200) {
          break;
        }

        is(markers.length, 0,
           'Transform animation running on the element which is scrolled out ' +
           'should be throttled until 200ms is elapsed');
      }

      is(markers.length, 1,
         'Transform animation running on the element which is scrolled out ' +
         'should be unthrottled after around 200ms have elapsed. now: ' +
         now + ' start time: ' + timeAtStart);

      await ensureElementRemoval(parentElement);
    }
  );

  add_task(
    async function restyling_transform_animations_in_scrolled_out_element() {
      if (!hasConformantPromiseHandling) {
        return;
      }

      await SpecialPowers.pushPrefEnv({ set: [["ui.showHideScrollbars", 1]] });

      // Make sure we start from the state right after requestAnimationFrame.
      await waitForFrame();

      var parentElement = addDiv(null,
        { style: 'overflow-y: scroll; height: 20px;' });
      var div = addDiv(null,
        { style: 'animation: rotate 100s; position: relative; top: 100px;' });
      parentElement.appendChild(div);
      var animation = div.getAnimations()[0];
      var timeAtStart = document.timeline.currentTime;

      ok(!animation.isRunningOnCompositor,
         'The transform animation is not running on the compositor');

      var markers;
      var now;
      while (true) {
        now = document.timeline.currentTime;
        if ((now - timeAtStart) >= 200) {
          // If the current time has elapsed over 200ms since the animation was
          // created, it means that the animation should have already
          // unthrottled in this tick, let's see what we observe in this tick's
          // restyling process.
          markers = await observeStyling(1);
          break;
        }

        markers = await observeStyling(1);
        is(markers.length, 0,
           'Transform animation running on the element which is scrolled out ' +
           'should be throttled until 200ms is elapsed');
      }

      is(markers.length, 1,
         'Transform animation running on the element which is scrolled out ' +
         'should be unthrottled after around 200ms have elapsed. now: ' +
         now + ' start time: ' + timeAtStart);

      await ensureElementRemoval(parentElement);
    }
  );

  add_task(
    async function restyling_out_of_view_transform_animations_in_another_element() {
      if (hasConformantPromiseHandling) {
        return;
      }

      // Skip this test on Android since this test have been failing
      // intermittently.
      // Bug 1413817: We should audit this test still fails once we have the
      // conformant Promise micro task.
      if (isAndroid) {
        return;
      }

      var parentElement = addDiv(null,
        { style: 'overflow: hidden;' });
      var div = addDiv(null,
        { style: 'animation: move-in 100s;' });
      parentElement.appendChild(div);
      var animation = div.getAnimations()[0];
      var timeAtStart = document.timeline.currentTime;

      ok(!animation.isRunningOnCompositor,
         'The transform animation on out of view element ' +
         'is not running on the compositor');

      var markers;
      var now;
      while (true) {
        markers = await observeStyling(1);
        // Check restyle markers until 200ms is elapsed.
        now = document.timeline.currentTime;
        if ((now - timeAtStart) >= 200) {
          break;
        }

        is(markers.length, 0,
           'Transform animation running on out of view element ' +
           'should be throttled until 200ms is elapsed');
      }

      is(markers.length, 1,
         'Transform animation running on out of view element ' +
         'should be unthrottled after around 200ms have elapsed. now: ' +
         now + ' start time: ' + timeAtStart);

      await ensureElementRemoval(parentElement);
    }
  );

  add_task(
    async function restyling_out_of_view_transform_animations_in_another_element() {
      if (!hasConformantPromiseHandling) {
        return;
      }

      // Make sure we start from the state right after requestAnimationFrame.
      await waitForFrame();

      var parentElement = addDiv(null,
        { style: 'overflow: hidden;' });
      var div = addDiv(null,
        { style: 'animation: move-in 100s;' });
      parentElement.appendChild(div);
      var animation = div.getAnimations()[0];
      var timeAtStart = document.timeline.currentTime;

      ok(!animation.isRunningOnCompositor,
         'The transform animation on out of view element ' +
         'is not running on the compositor');

      var markers;
      var now;
      while (true) {
        now = document.timeline.currentTime;
        if ((now - timeAtStart) >= 200) {
          // If the current time has elapsed over 200ms since the animation was
          // created, it means that the animation should have already
          // unthrottled in this tick, let's see what we observe in this tick's
          // restyling process.
          markers = await observeStyling(1);
          break;
        }

        markers = await observeStyling(1);
        is(markers.length, 0,
           'Transform animation running on out of view element ' +
           'should be throttled until 200ms is elapsed');
      }

      is(markers.length, 1,
         'Transform animation running on out of view element ' +
         'should be unthrottled after around 200ms have elapsed. now: ' +
         now + ' start time: ' + timeAtStart);

      await ensureElementRemoval(parentElement);
    }
  );

  add_task(async function restyling_main_thread_animations_in_scrolled_out_element() {
    var parentElement = addDiv(null,
      { style: 'overflow-y: scroll; height: 20px;' });
    var div = addDiv(null,
      { style: 'animation: background-color 100s; position: relative; top: 20px;' });
    parentElement.appendChild(div);
    var animation = div.getAnimations()[0];

    await animation.ready;
    var markers = await observeStyling(5);

    is(markers.length, 0,
       'Animations running on the main-thread for elements ' +
       'which are scrolled out should never cause restyles');

    await waitForWheelEvent(parentElement);

    // Make sure we are ready to restyle before counting restyles.
    await waitForFrame();

    markers = await observeStyling(5);
    is(markers.length, 5,
       'Animations running on the main-thread which were in scrolled out ' +
       'elements should update restyling soon after the element moved in ' +
       'view by scrolling');

    await ensureElementRemoval(parentElement);
  });

  add_task(async function restyling_main_thread_animations_in_nested_scrolled_out_element() {
    var grandParent = addDiv(null,
      { style: 'overflow-y: scroll; height: 20px;' });
    var parentElement = addDiv(null,
      { style: 'overflow-y: scroll; height: 100px;' });
    var div = addDiv(null,
      { style: 'animation: background-color 100s; ' +
               'position: relative; ' +
               'top: 20px;' }); // This element is in-view in the parent, but
                                // out of view in the grandparent.
    grandParent.appendChild(parentElement);
    parentElement.appendChild(div);
    var animation = div.getAnimations()[0];

    await animation.ready;
    var markers = await observeStyling(5);

    is(markers.length, 0,
       'Animations running on the main-thread which are in nested elements ' +
       'which are scrolled out should never cause restyles');

    await waitForWheelEvent(grandParent);

    await waitForFrame();

    markers = await observeStyling(5);
    is(markers.length, 5,
       'Animations running on the main-thread which were in nested scrolled ' +
       'out elements should update restyle soon after the element moved ' +
       'in view by scrolling');

    await ensureElementRemoval(grandParent);
  });

  add_task_if_omta_enabled(async function no_restyling_compositor_animations_in_visiblily_hidden_element() {
    var div = addDiv(null,
     { style: 'animation: opacity 100s; visibility: hidden' });
    var animation = div.getAnimations()[0];

    await animation.ready;
    ok(!SpecialPowers.wrap(animation).isRunningOnCompositor);

    var markers = await observeStyling(5);

    todo_is(markers.length, 0,
            'Bug 1237454: Animations running on the compositor in ' +
            'visibility hidden element should never cause restyles');
    await ensureElementRemoval(div);
  });

  add_task(async function restyling_main_thread_animations_move_out_of_view_by_scrolling() {
    var parentElement = addDiv(null,
      { style: 'overflow-y: scroll; height: 200px;' });
    var div = addDiv(null,
      { style: 'animation: background-color 100s;' });
    var pad = addDiv(null,
      { style: 'height: 400px;' });
    parentElement.appendChild(div);
    parentElement.appendChild(pad);
    var animation = div.getAnimations()[0];

    await animation.ready;

    await waitForWheelEvent(parentElement);

    await waitForFrame();

    var markers = await observeStyling(5);

    // FIXME: We should reduce a redundant restyle here.
    ok(markers.length >= 0,
       'Animations running on the main-thread which are in scrolled out ' +
       'elements should throttle restyling');

    await ensureElementRemoval(parentElement);
  });

  add_task(async function restyling_main_thread_animations_moved_in_view_by_resizing() {
    var parentElement = addDiv(null,
      { style: 'overflow-y: scroll; height: 20px;' });
    var div = addDiv(null,
      { style: 'animation: background-color 100s; position: relative; top: 100px;' });
    parentElement.appendChild(div);
    var animation = div.getAnimations()[0];

    await animation.ready;

    var markers = await observeStyling(5);
    is(markers.length, 0,
       'Animations running on the main-thread which is in scrolled out ' +
       'elements should not update restyling');

    parentElement.style.height = '100px';
    markers = await observeStyling(1);

    is(markers.length, 1,
       'Animations running on the main-thread which was in scrolled out ' +
       'elements should update restyling soon after the element moved in ' +
       'view by resizing');

    await ensureElementRemoval(parentElement);
  });

  add_task(async function no_restyling_main_thread_animations_in_visiblily_hidden_element() {
    var div = addDiv(null,
     { style: 'animation: background-color 100s; visibility: hidden' });
    var animation = div.getAnimations()[0];

    await animation.ready;
    var markers = await observeStyling(5);

    todo_is(markers.length, 0,
            'Bug 1237454: Animations running on the main-thread in ' +
            'visibility hidden element should never cause restyles');
    await ensureElementRemoval(div);
  });

  add_task_if_omta_enabled(async function no_restyling_compositor_animations_after_pause_is_called() {
    var div = addDiv(null, { style: 'animation: opacity 100s' });
    var animation = div.getAnimations()[0];

    await animation.ready;
    ok(SpecialPowers.wrap(animation).isRunningOnCompositor);

    animation.pause();

    await animation.ready;

    var markers = await observeStyling(1);
    is(markers.length, 1,
       'Animations running on the compositor should restyle once after ' +
       'Animation.pause() was called');

    markers = await observeStyling(5);
    is(markers.length, 0,
       'Paused animations running on the compositor should never cause ' +
       'restyles');
    await ensureElementRemoval(div);
  });

  add_task(async function no_restyling_main_thread_animations_after_pause_is_called() {
    var div = addDiv(null, { style: 'animation: background-color 100s' });
    var animation = div.getAnimations()[0];

    await animation.ready;

    animation.pause();

    await animation.ready;

    var markers = await observeStyling(1);
    is(markers.length, 1,
       'Animations running on the main-thread should restyle once after ' +
       'Animation.pause() was called');

    markers = await observeStyling(5);
    is(markers.length, 0,
       'Paused animations running on the main-thread should never cause ' +
       'restyles');
    await ensureElementRemoval(div);
  });

  add_task_if_omta_enabled(async function only_one_restyling_when_current_time_is_set_to_middle_of_duration() {
    var div = addDiv(null, { style: 'animation: opacity 100s' });
    var animation = div.getAnimations()[0];

    await animation.ready;

    animation.currentTime = 50 * MS_PER_SEC;

    var markers = await observeStyling(5);
    is(markers.length, 1,
       'Bug 1235478: Animations running on the compositor should only once ' +
       'update style when currentTime is set to middle of duration time');
    await ensureElementRemoval(div);
  });

  add_task_if_omta_enabled(async function change_duration_and_currenttime() {
    var div = addDiv(null);
    var animation = div.animate({ opacity: [ 0, 1 ] }, 100 * MS_PER_SEC);

    await animation.ready;
    ok(SpecialPowers.wrap(animation).isRunningOnCompositor);

    // Set currentTime to a time longer than duration.
    animation.currentTime = 500 * MS_PER_SEC;

    // Now the animation immediately get back from compositor.
    ok(!SpecialPowers.wrap(animation).isRunningOnCompositor);

    // Extend the duration.
    animation.effect.timing.duration = 800 * MS_PER_SEC;
    var markers = await observeStyling(5);
    is(markers.length, 1,
       'Animations running on the compositor should update style ' +
       'when timing.duration is made longer than the current time');

    await ensureElementRemoval(div);
  });

  add_task(async function script_animation_on_display_none_element() {
    var div = addDiv(null);
    var animation = div.animate({ backgroundColor: [ 'red', 'blue' ] },
                                100 * MS_PER_SEC);

    await animation.ready;

    div.style.display = 'none';

    // We need to wait a frame to apply display:none style.
    await waitForNextFrame();

    is(animation.playState, 'running',
       'Script animations keep running even when the target element has ' +
       '"display: none" style');

    ok(!SpecialPowers.wrap(animation).isRunningOnCompositor,
       'Script animations on "display:none" element should not run on the ' +
       'compositor');

    var markers = await observeStyling(5);
    is(markers.length, 0,
       'Script animations on "display: none" element should not update styles');

    div.style.display = '';

    // We need to wait a frame to unapply display:none style.
    await waitForNextFrame();

    var markers = await observeStyling(5);
    is(markers.length, 5,
       'Script animations restored from "display: none" state should update ' +
       'styles');

    await ensureElementRemoval(div);
  });

  add_task_if_omta_enabled(async function compositable_script_animation_on_display_none_element() {
    var div = addDiv(null);
    var animation = div.animate({ opacity: [ 0, 1 ] }, 100 * MS_PER_SEC);

    await animation.ready;

    div.style.display = 'none';

    // We need to wait a frame to apply display:none style.
    await waitForNextFrame();

    is(animation.playState, 'running',
       'Opacity script animations keep running even when the target element ' +
       'has "display: none" style');

    ok(!SpecialPowers.wrap(animation).isRunningOnCompositor,
       'Opacity script animations on "display:none" element should not ' +
       'run on the compositor');

    var markers = await observeStyling(5);
    is(markers.length, 0,
       'Opacity script animations on "display: none" element should not ' +
       'update styles');

    div.style.display = '';

    // We need to wait a frame to unapply display:none style.
    await waitForNextFrame();

    ok(SpecialPowers.wrap(animation).isRunningOnCompositor,
       'Opacity script animations restored from "display: none" should be ' +
       'run on the compositor');

    await ensureElementRemoval(div);
  });

  add_task(async function restyling_for_empty_keyframes() {
    var div = addDiv(null);
    var animation = div.animate({ }, 100 * MS_PER_SEC);

    await animation.ready;
    var markers = await observeStyling(5);

    is(markers.length, 0,
       'Animations with no keyframes should not cause restyles');

    animation.effect.setKeyframes({ backgroundColor: ['red', 'blue'] });
    markers = await observeStyling(5);

    is(markers.length, 5,
       'Setting valid keyframes should cause regular animation restyles to ' +
       'occur');

    animation.effect.setKeyframes({ });
    markers = await observeStyling(5);

    is(markers.length, 1,
       'Setting an empty set of keyframes should trigger a single restyle ' +
       'to remove the previous animated style');

    await ensureElementRemoval(div);
  });

  add_task_if_omta_enabled(async function no_restyling_when_animation_style_when_re_setting_same_animation_property() {
    var div = addDiv(null, { style: 'animation: opacity 100s' });
    var animation = div.getAnimations()[0];
    await animation.ready;
    ok(SpecialPowers.wrap(animation).isRunningOnCompositor);
    // Apply the same animation style
    div.style.animation = 'opacity 100s';
    var markers = await observeStyling(5);
    is(markers.length, 0,
       'Applying same animation style '  +
       'should never cause restyles');
    await ensureElementRemoval(div);
  });

  add_task(async function necessary_update_should_be_invoked() {
    var div = addDiv(null, { style: 'animation: background-color 100s' });
    var animation = div.getAnimations()[0];
    await animation.ready;
    await waitForAnimationFrames(5);
    // Apply another animation style
    div.style.animation = 'background-color 110s';
    var markers = await observeStyling(1);
    if (isServo) {
      // There should be two restyles.
      // 1) Animation-only restyle for before applying the new animation style
      // 2) Animation-only restyle for after applying the new animation style
      is(markers.length, 2,
         'Applying animation style with different duration '  +
         'should restyle twice');
    } else {
      // There should be three restyles.
      // 1) Animation-only restyle for before applying the new animation style
      // 2) Restyle for applying the new animation style
      //    Note: In gecko styling for animations is not separated.
      // 3) Restyle triggered by updating an existing animation (specifically
      //    the animation-duration)
      is(markers.length, 3,
         'Applying animation style with different duration '  +
         'should restyles three times');
    }
    await ensureElementRemoval(div);
  });

  add_task_if_omta_enabled(
    async function changing_cascading_result_for_main_thread_animation() {
      var div = addDiv(null, { style: 'background-color: blue' });
      var animation = div.animate({ opacity: [0, 1],
                                    backgroundColor: ['green', 'red'] },
                                  100 * MS_PER_SEC);
      await animation.ready;
      ok(SpecialPowers.wrap(animation).isRunningOnCompositor,
         'The opacity animation is running on the compositor');
      // Make the background-color style as !important to cause an update
      // to the cascade.
      // Bug 1300982: The background-color animation should be no longer
      // running on the main thread.
      div.style.setProperty('background-color', '1', 'important');
      var markers = await observeStyling(5);
      todo_is(markers.length, 0,
         'Changing cascading result for the property running on the main ' +
         'thread does not cause synchronization layer of opacity animation ' +
         'running on the compositor');
      await ensureElementRemoval(div);
    }
  );

  add_task(async function restyling_for_animation_on_orphaned_element() {
    var div = addDiv(null);
    var animation = div.animate({ marginLeft: [ '0px', '100px' ] },
                                100 * MS_PER_SEC);

    await animation.ready;

    div.remove();

    // It's possible that the animation begins at this moment.  If this is the
    // case, an additional superfluous restyle request that we will check later
    // can't be observed.
    const expectedRestyleCount = tweakExpectedRestyleCount(animation, 1);

    var markers = await observeStyling(5);
    is(markers.length, 0,
       'Animation on orphaned element should not cause restyles');

    document.body.appendChild(div);

    markers = await observeStyling(1);
    if (isServo) {
      // In Servo, we explicitly set important_rules_change flag to the element
      // in compute_style() during the initial normal traversal right after
      // re-attaching which leads to invoking a SequentialTask for
      // CascadeResults which ends up calling RequestRestyle(Standard). As a
      // result, the animation is restyled during a second animation restyle in
      // the first frame. If we fix the behavior when we attach an orphaned
      // element with script animations to a document so that it requests a
      // layer restyle (bug 1388557) before fixing important_rules_change in
      // compute_style() so that it no longer dispatches a needless standard
      // restyle (bug 1388560), we should add a test case that fails if we
      // continue to unnecessarily request a standard restyle.
      //
      // Bug 1417354: There will be an additional superfluous restyle request
      // which results when we detach an element from the document between
      // the Animation tick and styling, and then re-attach it.
      is(markers.length, expectedRestyleCount,
         'We should observe one restyle in the first frame right after ' +
         're-attaching to the document');
    } else {
      // Bug 1388557: We should call RequestRestyle(Layer) when an element which
      // has running script animations is attached to a document.
      todo_is(markers.length, 1,
              'Bug 1388557 We should observe one restyle in the first frame ' +
              'right after re-attaching to the document');
    }
    markers = await observeStyling(5);
    is(markers.length, 5,
       'Animation on re-attached to the document begins to update style');

    await ensureElementRemoval(div);
  });

  add_task_if_omta_enabled(
    // Tests that if we remove an element from the document whose animation
    // cascade needs recalculating, that it is correctly updated when it is
    // re-attached to the document.
    async function restyling_for_opacity_animation_on_re_attached_element() {
      var div = addDiv(null, { style: 'opacity: 1 ! important' });
      var animation = div.animate({ opacity: [0, 1] }, 100 * MS_PER_SEC);

      await animation.ready;
      ok(!SpecialPowers.wrap(animation).isRunningOnCompositor,
         'The opacity animation overridden by an !important rule is NOT ' +
         'running on the compositor');

      // Drop the !important rule to update the cascade.
      div.style.setProperty('opacity', '1', '');

      div.remove();

      var markers = await observeStyling(5);
      is(markers.length, 0,
         'Opacity animation on orphaned element should not cause restyles');

      document.body.appendChild(div);

      // Need a frame to give the animation a chance to be sent to the
      // compositor.
      await waitForNextFrame();

      ok(SpecialPowers.wrap(animation).isRunningOnCompositor,
         'The opacity animation which is no longer overridden by the ' +
         '!important rule begins running on the compositor even if the ' +
         '!important rule had been dropped before the target element was ' +
         'removed');

      await ensureElementRemoval(div);
    }
  );

  add_task(
    async function no_throttling_additive_animations_out_of_view_element() {
      var div = addDiv(null, { style: 'transform: translateY(-400px);' });
      var animation =
        div.animate([{ visibility: 'visible' }],
                    { duration: 100 * MS_PER_SEC, composite: 'add' });

      await animation.ready;

      const expectedRestyleCount = tweakExpectedRestyleCount(animation, 5);
      var markers = await observeStyling(5);

      is(markers.length, expectedRestyleCount,
         'Additive animation has no keyframe whose offset is 0 or 1 in an ' +
         'out-of-view element should not be throttled');
      await ensureElementRemoval(div);
    }
  );

  // Tests that missing keyframes animations don't throttle at all.
  add_task(async function no_throttling_animations_out_of_view_element() {
    var div = addDiv(null, { style: 'transform: translateY(-400px);' });
    var animation =
      div.animate([{ visibility: 'visible' }], 100 * MS_PER_SEC);

    await animation.ready;

    const expectedRestyleCount = tweakExpectedRestyleCount(animation, 5);
    var markers = await observeStyling(5);

    is(markers.length, expectedRestyleCount,
       'Discrete animation has has no keyframe whose offset is 0 or 1 in an ' +
       'out-of-view element should not be throttled');
    await ensureElementRemoval(div);
  });

  // Tests that missing keyframes animation on scrolled out element that the
  // animation is not able to be throttled.
  add_task(
    async function no_throttling_missing_keyframe_animations_out_of_view_element() {
      var div =
        addDiv(null, { style: 'transform: translateY(-400px);' +
                              'visibility: collapse;' });
      var animation =
        div.animate([{ visibility: 'visible' }], 100 * MS_PER_SEC);
      await animation.ready;

      const expectedRestyleCount = tweakExpectedRestyleCount(animation, 5);
      var markers = await observeStyling(5);
      is(markers.length, expectedRestyleCount,
         'visibility animation has no keyframe whose offset is 0 or 1 in an ' +
         'out-of-view element and produces change hint other than paint-only ' +
         'change hint should not be throttled');
      await ensureElementRemoval(div);
    }
  );

  // Counter part of the above test.
  add_task(async function no_restyling_discrete_animations_out_of_view_element() {
    var div = addDiv(null, { style: 'transform: translateY(-400px);' });
    var animation =
      div.animate({ visibility: ['visible', 'hidden'] }, 100 * MS_PER_SEC);

    await animation.ready;

    var markers = await observeStyling(5);

    is(markers.length, 0,
       'Discrete animation running on the main-thread in an out-of-view ' +
       'element should never cause restyles');
    await ensureElementRemoval(div);
  });

  add_task(async function no_restyling_while_computed_timing_is_not_changed() {
    var div = addDiv(null);
    var animation = div.animate({ backgroundColor: [ 'red', 'blue' ] },
                                { duration: 100 * MS_PER_SEC,
                                  easing: 'step-end' });

    await animation.ready;

    var markers = await observeStyling(5);

    is(markers.length, 0,
       'Animation running on the main-thread while computed timing is not ' +
       'changed should never cause restyles');
    await ensureElementRemoval(div);
  });

  add_task(async function no_throttling_animations_in_view_svg() {
    var div = addDiv(null, { style: 'overflow: scroll;' +
                                    'height: 100px; width: 100px;' });
    var svg = addSVGElement(div, 'svg', { viewBox: '-10 -10 0.1 0.1',
                                          width:   '50px',
                                          height:  '50px' });
    var rect = addSVGElement(svg, 'rect', { x:      '-10',
                                            y:      '-10',
                                            width:  '10',
                                            height: '10',
                                            fill:   'red' });
    var animation = rect.animate({ fill: ['blue', 'lime'] }, 100 * MS_PER_SEC);
    await animation.ready;

    const expectedRestyleCount = tweakExpectedRestyleCount(animation, 5);
    var markers = await observeStyling(5);
    is(markers.length, expectedRestyleCount,
       'CSS animations on an in-view svg element with post-transform should ' +
       'not be throttled.');

    await ensureElementRemoval(div);
  });

  add_task(async function throttling_animations_out_of_view_svg() {
    var div = addDiv(null, { style: 'overflow: scroll;' +
                                    'height: 100px; width: 100px;' });
    var svg = addSVGElement(div, 'svg', { viewBox: '-10 -10 0.1 0.1',
                                          width: '50px',
                                          height: '50px' });
    var rect = addSVGElement(svg, 'rect', { width: '10',
                                            height: '10',
                                            fill: 'red' });

    var animation = rect.animate({ fill: ['blue', 'lime'] }, 100 * MS_PER_SEC);
    await animation.ready;

    var markers = await observeStyling(5);
    is(markers.length, 0,
       'CSS animations on an out-of-view svg element with post-transform ' +
       'should be throttled.');

    await ensureElementRemoval(div);
  });

  add_task(async function no_throttling_animations_in_view_css_transform() {
    var scrollDiv = addDiv(null, { style: 'overflow: scroll; ' +
                                          'height: 100px; width: 100px;' });
    var targetDiv = addDiv(null,
                           { style: 'animation: background-color 100s;' +
                                    'transform: translate(-50px, -50px);' });
    scrollDiv.appendChild(targetDiv);

    var animation = targetDiv.getAnimations()[0];
    await animation.ready;

    const expectedRestyleCount = tweakExpectedRestyleCount(animation, 5);
    var markers = await observeStyling(5);
    is(markers.length, expectedRestyleCount,
       'CSS animation on an in-view element with pre-transform should not ' +
       'be throttled.');

    await ensureElementRemoval(scrollDiv);
  });

  add_task(async function throttling_animations_out_of_view_css_transform() {
    var scrollDiv = addDiv(null, { style: 'overflow: scroll;' +
                                          'height: 100px; width: 100px;' });
    var targetDiv = addDiv(null,
                           { style: 'animation: background-color 100s;' +
                                    'transform: translate(100px, 100px);' });
    scrollDiv.appendChild(targetDiv);

    var animation = targetDiv.getAnimations()[0];
    await animation.ready;

    var markers = await observeStyling(5);
    is(markers.length, 0,
       'CSS animation on an out-of-view element with pre-transform should be ' +
       'throttled.');

    await ensureElementRemoval(scrollDiv);
  });

  add_task(
    async function throttling_animations_in_out_of_view_position_absolute_element() {
      var parentDiv = addDiv(null,
                             { style: 'position: absolute; top: -1000px;' });
      var targetDiv = addDiv(null,
                             { style: 'animation: background-color 100s;' });
      parentDiv.appendChild(targetDiv);

      var animation = targetDiv.getAnimations()[0];
      await animation.ready;

      var markers = await observeStyling(5);
      is(markers.length, 0,
         'CSS animation in an out-of-view position absolute element should ' +
         'be throttled');

      await ensureElementRemoval(parentDiv);
    }
  );

  add_task(
    async function throttling_animations_on_out_of_view_position_absolute_element() {
      var div = addDiv(null,
                       { style: 'animation: background-color 100s; ' +
                                'position: absolute; top: -1000px;' });

      var animation = div.getAnimations()[0];
      await animation.ready;

      var markers = await observeStyling(5);
      is(markers.length, 0,
         'CSS animation on an out-of-view position absolute element should ' +
         'be throttled');

      await ensureElementRemoval(div);
    }
  );

  add_task(
    async function throttling_animations_in_out_of_view_position_fixed_element() {
      var parentDiv = addDiv(null,
                             { style: 'position: fixed; top: -1000px;' });
      var targetDiv = addDiv(null,
                             { style: 'animation: background-color 100s;' });
      parentDiv.appendChild(targetDiv);

      var animation = targetDiv.getAnimations()[0];
      await animation.ready;

      var markers = await observeStyling(5);
      is(markers.length, 0,
         'CSS animation on an out-of-view position:fixed element should be ' +
         'throttled');

      await ensureElementRemoval(parentDiv);
    }
  );

  add_task(
    async function throttling_animations_on_out_of_view_position_fixed_element() {
      var div = addDiv(null,
                       { style: 'animation: background-color 100s; ' +
                                'position: fixed; top: -1000px;' });

      var animation = div.getAnimations()[0];
      await animation.ready;

      var markers = await observeStyling(5);
      is(markers.length, 0,
         'CSS animation on an out-of-view position:fixed element should be ' +
         'throttled');

      await ensureElementRemoval(div);
    }
  );

  add_task_if_omta_enabled(
    async function no_restyling_for_compositor_animation_on_unrelated_style_change() {
      var div = addDiv(null);
      var animation = div.animate({ opacity: [0, 1] }, 100 * MS_PER_SEC);

      await animation.ready;
      ok(SpecialPowers.wrap(animation).isRunningOnCompositor,
         'The opacity animation is running on the compositor');

      div.style.setProperty('color', 'blue', '');
      var markers = await observeStyling(5);
      if (isServo) {
        is(markers.length, 0,
           'The opacity animation keeps running on the compositor when ' +
           'color style is changed');
      } else {
        todo_is(markers.length, 0,
                'Bug 1307341 The opacity animation keeps running on the ' +
                'compositor when color style is changed');
      }
      await ensureElementRemoval(div);
    }
  );
});

</script>
</body>
