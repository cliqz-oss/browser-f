/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include "mozilla-config.h"
#include "AccessibleHandler.h"

import "ocidl.idl";
import "ServProv.idl";

import "Accessible2_3.idl";
import "AccessibleHypertext2.idl";
import "AccessibleHyperlink.idl";
import "AccessibleTable.idl";
import "AccessibleTable2.idl";
import "AccessibleTableCell.idl";

typedef struct _StaticIA2Data
{
  NEWEST_IA2_INTERFACE* mIA2;
  IAccessibleHypertext2* mIAHypertext;
  IAccessibleHyperlink* mIAHyperlink;
  IAccessibleTable* mIATable;
  IAccessibleTable2* mIATable2;
  IAccessibleTableCell* mIATableCell;
} StaticIA2Data;

typedef struct _DynamicIA2Data
{
  // From IAccessible/IAccessible2
  VARIANT           mRole;
  long              mState;
  long              mChildCount;
  long              mIA2Role;
  AccessibleStates  mIA2States;
  long              mLeft;
  long              mTop;
  long              mWidth;
  long              mHeight;
  long              mHwnd;
  BSTR              mKeyboardShortcut;
  BSTR              mName;
  BSTR              mDescription;
  BSTR              mDefaultAction;
  BSTR              mValue;
  BSTR              mAttributes;
  IA2Locale         mIA2Locale;
  // From IAccessibleAction
  long              mNActions;
  // From IAccessibleTableCell
  long              mRowIndex;
  long              mColumnIndex;
  long              mRowExtent;
  long              mColumnExtent;
  boolean           mCellIsSelected;
  // From IAccessible2
  long              mUniqueId;
} DynamicIA2Data;

interface IGeckoBackChannel;

// We define different CLSIDs and IIDs depending on channel and officiality.
// This prevents handlers from installing overtop one another when multiple
// channels are present. Note that we do not do this for all UUIDs in this IDL,
// just the ones that are written to the registry (coclass and interfaces that
// have the [object] annotation)
// Cliqz. Replace all IIDs and CLSIDs with new one.

#if defined(USE_LOCAL_UUID)

# if defined(DEBUG)

// Local debug builds
#  define HANDLER_CLSID 0f6146af-391c-43f2-9f42-00981d94c639
#  define IHANDLERCONTROL_IID caede6f7-5472-43e5-830c-d43b2d1a66ca
#  define ASYNCIHANDLERCONTROL_IID 80d5355d-eb3f-4ff0-b2fd-6bad9085c2d6
#  define IGECKOBACKCHANNEL_IID d710c75b-cc22-4e21-84f5-ddce3a25d5a2

# else

// Local non-debug builds
#  define HANDLER_CLSID 3c51e191-27d1-44fd-99f7-1441517ccd2b
#  define IHANDLERCONTROL_IID 16ce38d5-e4c7-4cea-a4ac-9e44fa97e7ee
#  define ASYNCIHANDLERCONTROL_IID 90717112-269e-4179-b7fa-07c1fc5df3bd
#  define IGECKOBACKCHANNEL_IID b1c9e091-1517-45b1-acb1-9b18d616f7b6

# endif

#elif defined(NIGHTLY_BUILD)

// Nightly Builds
# define IHANDLERCONTROL_IID 88eab8e4-71af-47d4-b6d9-000daa0a18fd
# define ASYNCIHANDLERCONTROL_IID d34578d8-3ef3-4e4d-bb4c-474cc7ee6d42
# define HANDLER_CLSID de60b576-5a7e-483d-9995-65fd167ca7a6
# define IGECKOBACKCHANNEL_IID 01d3bf43-136d-49ea-a811-38ea93508552

#elif defined(USE_BETA_UUID)

// Beta Builds
# define IHANDLERCONTROL_IID ae036bc3-f3ad-44cb-95f8-d048ec866a4f
# define ASYNCIHANDLERCONTROL_IID 9f8e9499-59d4-4ee6-ba9e-b43e11de90b9
# define HANDLER_CLSID 6f5b5345-51eb-4e75-8c11-5725754cc9cb
# define IGECKOBACKCHANNEL_IID 4840e22d-4633-41b0-85f1-6e3a23151a72

#elif defined(RELEASE_OR_BETA)

// Release Builds
# define IHANDLERCONTROL_IID 3d4ec06a-033c-4532-a2af-08a60b5b8fe3
# define ASYNCIHANDLERCONTROL_IID 4e221d45-4f0f-450c-8a00-8e12f4f925c5
# define HANDLER_CLSID bf5bd390-99dc-4d49-9cf0-7619a7665331
# define IGECKOBACKCHANNEL_IID 8c1ae885-b95d-4b73-afd3-9f3dc0c453a7

#else

// Catch-all
# define IHANDLERCONTROL_IID f7ad0116-2ef5-46e6-88fb-c8c94a863b6b
# define ASYNCIHANDLERCONTROL_IID 2fc76c26-aa49-419c-b11a-09aac1c176aa
# define HANDLER_CLSID 0ec0c06f-fae6-4336-b54e-4670ae982249
# define IGECKOBACKCHANNEL_IID f1a3b885-e0d1-4701-83c7-23dc60285c8a

#endif

[uuid(aee90e31-1ea6-4c9d-a94d-be871af3b519)]
interface HandlerData
{
  typedef struct _IA2Payload
  {
    StaticIA2Data mStaticData;
    DynamicIA2Data mDynamicData;
    IGeckoBackChannel* mGeckoBackChannel;
  } IA2Payload;
}

[object,
 uuid(IHANDLERCONTROL_IID),
 async_uuid(ASYNCIHANDLERCONTROL_IID),
 pointer_default(unique)]
interface IHandlerControl : IUnknown
{
  HRESULT Invalidate();
  HRESULT OnTextChange([in] long aHwnd, [in] long aIA2UniqueId,
                       [in] VARIANT_BOOL aIsInsert,
                       [in] IA2TextSegment* aText);
}

typedef struct _IARelationData
{
  BSTR mType;
  long mNTargets;
} IARelationData;

typedef struct _AccChildData
{
  NEWEST_IA2_INTERFACE* mAccessible;
  BSTR mText;
  long mTextRole;
  long mTextId;
  long mTextState;
  long mTextLeft;
  long mTextTop;
  long mTextWidth;
  long mTextHeight;
} AccChildData;

[object,
 uuid(IGECKOBACKCHANNEL_IID),
 pointer_default(unique)]
interface IGeckoBackChannel : IUnknown
{
  [propput] HRESULT HandlerControl([in] long aPid, [in] IHandlerControl* aCtrl);
  HRESULT Refresh([out] DynamicIA2Data* aOutData);
  [propget] HRESULT AllTextInfo([out] BSTR* aText,
    [out, size_is(,*aNHyperlinks)] IAccessibleHyperlink*** aHyperlinks,
    [out] long* aNHyperlinks,
    [out, size_is(,*aNAttribRuns)] IA2TextSegment** aAttribRuns,
    [out] long* aNAttribRuns);
  [propget] HRESULT RelationsInfo(
    [out, size_is(,*aNRelations)] IARelationData** aRelations,
    [out] long* aNRelations);
  [propget] HRESULT AllChildren(
    [out, size_is(,*aNChildren)] AccChildData** aChildren,
    [out] ULONG* aNChildren);
}

[uuid(3e896b66-6859-447d-a050-40c72ef43ebd)]
library AccessibleHandlerTypeLib
{
  /**
   * This definition is required in order for the handler implementation to
   * support IDispatch (aka Automation). This is used by interpreted language
   * FFIs to discover which interfaces may be controlled via IDispatch.
   * (In particular, the python FFI used by NVDA needs this).
   *
   * In reality, the only a11y interface that is Automation compliant is
   * IAccessible; our remaining interfaces are not.
   *
   * Once the FFI knows that IAccessible is supported, the FFI queries for
   * IAccessible and is then able to resolve non-automation interfaces from
   * there.
   */
  [uuid(HANDLER_CLSID)]
  coclass AccessibleHandler
  {
    [default] interface IAccessible;
  };
};
