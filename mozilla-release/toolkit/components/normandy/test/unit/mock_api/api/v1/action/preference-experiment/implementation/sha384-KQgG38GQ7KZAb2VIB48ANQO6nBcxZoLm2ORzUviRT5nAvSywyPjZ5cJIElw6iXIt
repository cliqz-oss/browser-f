(function(a){function b(d){if(c[d])return c[d].exports;var e=c[d]={exports:{},id:d,loaded:!1};return a[d].call(e.exports,e,e.exports,b),e.loaded=!0,e.exports}var c={};return b.m=a,b.c=c,b.p="",b(0)})([function(a,b,c){"use strict";async function e(i){if(void 0===i.preferenceExperiments)return void i.log("Client does not support preference experiments, aborting.","info");const j=await i.preferenceExperiments.getAllActive();for(const k of j)g.includes(k.name)||(await i.preferenceExperiments.stop(k.name,!0))}Object.defineProperty(b,"__esModule",{value:!0}),b.resetAction=function(){g=[]},b.postExecutionHook=e;var f=c(1);let g=[];class h extends f.Action{async execute(){var i=this.recipe.arguments;const j=i.slug,k=i.preferenceName,l=i.preferenceBranchType,m=i.branches,n=i.preferenceType,o=this.normandy.preferenceExperiments;if(void 0===o)return void this.normandy.log("Client does not support preference experiments, aborting.","info");g.push(j);const p=await o.has(j);if(!p){const q=await o.getAllActive(),r=q.some((t)=>t.preferenceName===k);if(r)return void this.normandy.log(`Experiment ${j} ignored; another active experiment is already using the
	          ${k} preference.`,"warn");const s=await this.chooseBranch(m);await o.start({name:j,branch:s.slug,preferenceName:k,preferenceValue:s.value,preferenceBranchType:l,preferenceType:n})}else{const q=await o.get(j);q.expired?this.normandy.log(`Experiment ${j} has expired, aborting.`,"debug"):await o.markLastSeen(j)}}async chooseBranch(i){const j=this.recipe.arguments.slug,k=i.map((n)=>n.ratio),l=`${this.normandy.userId}-${j}-branch`,m=await this.normandy.ratioSample(l,k);return i[m]}}b.default=h,(0,f.registerAction)("preference-experiment",h),(0,f.registerAsyncCallback)("postExecution",e)},function(a,b){(function(c){"use strict";Object.defineProperty(b,"__esModule",{value:!0});b.Action=class{constructor(g,h){this.normandy=g,this.recipe=h}};const e=b.registerAction=c&&c.registerAction||window&&window.registerAction||function(){},f=b.registerAsyncCallback=c&&c.registerAsyncCallback||window&&window.registerAsyncCallback||function(){}}).call(b,function(){return this}())}]);